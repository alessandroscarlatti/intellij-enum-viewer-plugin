package com.scarlatti.intellij.data.viewer.ui;

import com.intellij.uiDesigner.core.GridConstraints;
import com.intellij.uiDesigner.core.GridLayoutManager;
import com.intellij.uiDesigner.core.Spacer;

import javax.swing.*;
import javax.swing.table.*;
import java.awt.*;
import java.util.*;
import java.util.List;

/**
 * ______    __                         __           ____             __     __  __  _
 * ___/ _ | / /__ ___ ___ ___ ____  ___/ /______    / __/______ _____/ /__ _/ /_/ /_(_)
 * __/ __ |/ / -_|_-<(_-</ _ `/ _ \/ _  / __/ _ \  _\ \/ __/ _ `/ __/ / _ `/ __/ __/ /
 * /_/ |_/_/\__/___/___/\_,_/_//_/\_,_/_/  \___/ /___/\__/\_,_/_/ /_/\_,_/\__/\__/_/
 * Friday, 8/24/2018
 */
public class CdTable2 implements UIComponent {
    private JTable table;
    private JPanel jPanel;

    private List<EnumConstructor> constructors;
    private Map<String, Integer> paramNames = new HashMap<>();
    private DefaultTableModel model;

    public CdTable2(List<EnumConstructor> constructors) {
        this.constructors = constructors;
        setupTable();
        addData();
        updateRowHeights();
    }

    @Override
    public JPanel getJPanel() {
        return jPanel;
    }

    private void setupTable() {

        model = new DefaultTableModel(0, 4) {
            // all columns are strings.
            @Override
            public Class<?> getColumnClass(int columnIndex) {
                return String.class;
            }

            // all cells are editable.
            @Override
            public boolean isCellEditable(int row, int column) {
                return true;
            }

            // don't do anything special for now.
            // we will probably need selection capabilities later.
            DefaultTableModel init() {
//                addTableModelListener(e -> {
//                    if (e.getColumn() == 0 && e.getFirstRow() == e.getLastRow()) {
//                        int actualIndex = table.convertRowIndexToModel(e.getFirstRow());
//                        keyStores.get(actualIndex).setSelected(
//                            (Boolean) model.getValueAt(actualIndex, e.getColumn())
//                        );
//
//                    }
//                });
                return this;
            }

        }.init();  // not sure why the default constructor causes an intellij exception?!?
        table.setModel(model);

        TableColumnModel columnModel = new DefaultTableColumnModel();

        int clmIndex = 0;
        for (EnumConstructor constructor : constructors) {
            for (EnumConstructorParam param : constructor.getParams()) {

                if (paramNames.containsKey(param.getId()))
                    continue;

                CustomCellUiComponent uiComponent = new TwoButtonCellRenderer();
                CustomComponentRenderer renderer = new CustomComponentRenderer(uiComponent);

                TableColumn tableColumn = new TableColumn(clmIndex);
                tableColumn.setCellRenderer(renderer);
                tableColumn.setCellEditor(renderer);
                columnModel.addColumn(tableColumn);
                columnModel.getColumn(clmIndex).setHeaderValue(param.getId());
                paramNames.put(param.getId(), clmIndex);
                clmIndex++;
            }
        }

        table.setColumnModel(columnModel);
        table.putClientProperty("terminateEditOnFocusLost", true);
        table.getSelectionModel().setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
    }

    private void addData() {
        for (EnumConstructor constructor : constructors) {

            String[] params = new String[paramNames.size()];

            for (EnumConstructorParam param : constructor.getParams()) {
                params[paramNames.get(param.getId())] = param.getText();
            }

            model.addRow(params);
        }
    }

    private void updateRowHeights()
    {
        for (int row = 0; row < table.getRowCount(); row++)
        {
            int rowHeight = table.getRowHeight();

            for (int column = 0; column < table.getColumnCount(); column++)
            {
                Component comp = table.prepareRenderer(table.getCellRenderer(row, column), row, column);
                rowHeight = Math.max(rowHeight, comp.getPreferredSize().height);
            }

            table.setRowHeight(row, rowHeight);
        }
    }

    {
// GUI initializer generated by IntelliJ IDEA GUI Designer
// >>> IMPORTANT!! <<<
// DO NOT EDIT OR ADD ANY CODE HERE!
        $$$setupUI$$$();
    }

    /**
     * Method generated by IntelliJ IDEA GUI Designer
     * >>> IMPORTANT!! <<<
     * DO NOT edit this method OR call it in your code!
     *
     * @noinspection ALL
     */
    private void $$$setupUI$$$() {
        jPanel = new JPanel();
        jPanel.setLayout(new GridLayoutManager(2, 2, new Insets(0, 0, 0, 0), -1, -1));
        final JPanel panel1 = new JPanel();
        panel1.setLayout(new GridLayoutManager(1, 1, new Insets(0, 0, 0, 0), -1, -1));
        jPanel.add(panel1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
        final Spacer spacer1 = new Spacer();
        jPanel.add(spacer1, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));
        final Spacer spacer2 = new Spacer();
        jPanel.add(spacer2, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_VERTICAL, 1, GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));
        final JPanel panel2 = new JPanel();
        panel2.setLayout(new GridLayoutManager(1, 1, new Insets(0, 0, 0, 0), -1, -1));
        jPanel.add(panel2, new GridConstraints(1, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
        final JScrollPane scrollPane1 = new JScrollPane();
        panel2.add(scrollPane1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));
        table = new JTable();
        Font tableFont = this.$$$getFont$$$(null, -1, 20, table.getFont());
        if (tableFont != null) table.setFont(tableFont);
        scrollPane1.setViewportView(table);
    }

    /**
     * @noinspection ALL
     */
    private Font $$$getFont$$$(String fontName, int style, int size, Font currentFont) {
        if (currentFont == null) return null;
        String resultName;
        if (fontName == null) {
            resultName = currentFont.getName();
        } else {
            Font testFont = new Font(fontName, Font.PLAIN, 10);
            if (testFont.canDisplay('a') && testFont.canDisplay('1')) {
                resultName = fontName;
            } else {
                resultName = currentFont.getName();
            }
        }
        return new Font(resultName, style >= 0 ? style : currentFont.getStyle(), size >= 0 ? size : currentFont.getSize());
    }

    /**
     * @noinspection ALL
     */
    public JComponent $$$getRootComponent$$$() {
        return jPanel;
    }

    /**
     * @version 1.0 11/09/98
     */

    class CustomComponentRenderer extends DefaultCellEditor implements TableCellRenderer {
        protected JComponent ui;
        private CustomCellUiComponent uiComponent;

        private String value;

        public CustomComponentRenderer(CustomCellUiComponent uiComponent) {
            super(new JTextField());
            this.uiComponent = uiComponent;
            ui = uiComponent.getUi();
            ui.setOpaque(true);
//            ui.addActionListener(e -> fireEditingStopped());
        }

        public Component getTableCellEditorComponent(JTable table, Object value,
                                                     boolean isSelected, int row, int column) {
            if (isSelected) {
                ui.setForeground(table.getSelectionForeground());
                ui.setBackground(table.getSelectionBackground());
            } else {
                ui.setForeground(table.getForeground());
                ui.setBackground(table.getBackground());
            }
            this.value = (value == null) ? "" : value.toString();
            uiComponent.setValue(this.value);
            return ui;
        }

        public Component getTableCellRendererComponent(JTable table, Object value,
                                                       boolean isSelected, boolean hasFocus, int row, int column) {
            if (isSelected) {
                ui.setForeground(table.getSelectionForeground());
                ui.setBackground(table.getSelectionBackground());
            } else {
                ui.setForeground(table.getForeground());
                ui.setBackground(UIManager.getColor("Button.background"));
            }
            uiComponent.setValue((value == null) ? "" : value.toString());
            return ui;
        }

        public Object getCellEditorValue() {
            return new String(value);
        }
    }
}
